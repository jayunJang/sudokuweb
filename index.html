<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Sudoku Festival – Archive (Top 9)</title>
  <style>
@import url('https://fonts.googleapis.com/css2?family=Lexend+Deca:wght@100..900&family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

:root{
  --red:#E7364E; --white:#fff; --blue:#9ED4FF;
  --gap: 8px;
  --stroke: 2px;
  --shadow: 0 4px 12px rgba(0,0,0,.18);
}

html,body{ width:100%; background:#fff; }
body{
  margin:0;
  overflow:auto;
  font-family:"Lexend Deca", system-ui;
  color:rgba(231,54,78,1.0);
}

/* 스크롤 가능한 캔버스 */
#canvas{ position:relative; width:100%; height:190vh; }

/* LAYERS */
.layer{ position:absolute; inset:0; pointer-events:none; }
#bg1{ z-index:1; background:url('bg1.png') center/cover no-repeat; }
#bg2-wrap{ z-index:3; display:flex; align-items:center; justify-content:center; margin:120px; padding-top:230px;}
#bg2{ width:900px; max-width:none; display:block; }
#bg3{ z-index:4; background:url('bg3.png') right/contain no-repeat; margin:70px; }

/* TAGLINE */
.tagline{
  position:fixed; left:50%; top:24px; transform:translateX(-50%);
  z-index:8; color:var(--white);
  font-weight:800; letter-spacing:.2px; padding:8px 14px;
  background:var(--red); border-radius:10px; box-shadow:var(--shadow); pointer-events:none
}

/* STAGE */
#stage{ position:absolute; inset:0; z-index:6; pointer-events:none; }

/* CHIP */
.chip{
  position:fixed;
  display:flex; align-items:center; gap:var(--gap);
  cursor:grab; touch-action:none; pointer-events:auto; padding-left:50px;
}
.chip.dragging{ cursor:grabbing; }
.chip img.num{ width: calc(var(--scale, 1) * clamp(64px, 12vw, 85px)); height:auto; display:block; }

/* META */
.meta{
  display:flex; flex-direction:column; gap:2px; font-weight:600; line-height:1.1; text-align:left;
  color:rgba(231,54,78,1.0);
  text-shadow:
    1px  1px 0 #fff, -1px  1px 0 #fff,
    1px -1px 0 #fff, -1px -1px 0 #fff,
    0    2px 0 #fff,  0   -2px 0 #fff,
    2px  0   0 #fff, -2px  0   0 #fff;
}
.meta .name{ font-size:clamp(18px,2.4vw,22px); }
.meta .time{ font-size:clamp(16px,2.0vw,18px); opacity:.95; }
  </style>
</head>
<body>
  <div id="canvas">
    <div id="bg1" class="layer"></div>
    <div id="bg2-wrap" class="layer"><img id="bg2" src="bg2.png" alt="bg2"/></div>
    <div id="bg3" class="layer"></div>
    <div id="stage"></div>
  </div>

<script>
/** CONFIG */
const NUM_ASSETS = [
  {rank:1, src:'n1.png'},{rank:2, src:'n2.png'},{rank:3, src:'n3.png'},
  {rank:4, src:'n4.png'},{rank:5, src:'n5.png'},{rank:6, src:'n6.png'},
  {rank:7, src:'n7.png'},{rank:8, src:'n8.png'},{rank:9, src:'n9.png'},
];
let ranking = Array.from({length:9}, ()=>({name:'—', time:'—'}));

/* ELEMENTS */
const canvas = document.getElementById('canvas');
const stage  = document.getElementById('stage');
const bg2Wrap = document.getElementById('bg2-wrap');
const bg2 = document.getElementById('bg2');
const chips = [];

/* BG2 */
let b2 = {x:0, y:0, vx:0.02, vy:0.015};
function layoutBg2(){
  const rect = canvas.getBoundingClientRect();
  b2.x = rect.width * 0.5 - bg2.clientWidth * 0.5;
  b2.y = rect.height * 0.5 - bg2.clientHeight * 0.5;
}
window.addEventListener('load', layoutBg2);
window.addEventListener('resize', layoutBg2);

/* CHIPS */
function createChips(){
  stage.innerHTML = ''; chips.length = 0;
  NUM_ASSETS.forEach((item, i) => {
    const chipEl = document.createElement('div');
    chipEl.className = 'chip';
    const col = i % 3, row = Math.floor(i / 3);
    const startX = (5 + col*30) * window.innerWidth / 100;
    const startY = (15 + row*30) * window.innerHeight / 100 + window.scrollY;

    const img = new Image();
    img.className = 'num'; img.src = item.src; img.alt = 'rank ' + item.rank;
    if (item.rank === 4) img.style.setProperty('--scale', '1.2');

    const meta = document.createElement('div'); meta.className = 'meta';
    const name = document.createElement('div'); name.className = 'name'; name.textContent = ranking[i]?.name || '—';
    const time = document.createElement('div'); time.className = 'time'; time.textContent = ranking[i]?.time || '—';
    meta.append(name, time);
    chipEl.append(img, meta);
    stage.appendChild(chipEl);

    const chip = { el: chipEl, img, meta, name, time,
      x:startX, y:startY,
      vx:(Math.random()*0.05+0.015)*(Math.random()<.5?-1:1),
      vy:(Math.random()*0.05+0.015)*(Math.random()<.5?-1:1)
    };
    chips.push(chip);
    applyChipTransform(chip);
    enableDrag(chip);
  });
}

/* DRAG */
function enableDrag(chip){
  let dragging=false, lastT=0, grabDX=0, grabDY=0, prevX=0, prevY=0;
  const el = chip.el;

  const onPointerDown = (e)=>{
    dragging=true; chip.dragging=true; el.classList.add('dragging'); el.setPointerCapture(e.pointerId);
    const rect = el.getBoundingClientRect();
    grabDX = e.clientX - rect.left; grabDY = e.clientY - rect.top;
    prevX = chip.x; prevY = chip.y; lastT = performance.now(); chip.vx = chip.vy = 0;
  };
  const onPointerMove = (e)=>{
    if(!dragging) return;
    chip.x = e.clientX - grabDX; chip.y = e.clientY - grabDY;
    applyChipTransform(chip);
    const now = performance.now(), dt = Math.max(1, now - lastT);
    chip.vx = (chip.x - prevX) / dt; chip.vy = (chip.y - prevY) / dt;
    prevX = chip.x; prevY = chip.y; lastT = now;
  };
  const onPointerUp = ()=>{ dragging=false; chip.dragging=false; el.classList.remove('dragging'); };
  el.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

/* BOUNDS */
function applyChipTransform(chip){
  const w = chip.el.offsetWidth, h = chip.el.offsetHeight;
  const stageW = window.innerWidth, stageH = window.innerHeight;
  if (chip.x < 0) chip.x = 0;
  if (chip.y < 0) chip.y = 0;
  if (chip.x + w > stageW) chip.x = stageW - w;
  if (chip.y + h > stageH) chip.y = stageH - h;
  chip.el.style.transform = `translate3d(${chip.x}px, ${chip.y}px, 0)`;
}

/* TICK */
let last = performance.now();
function tick(now){
  const dt = Math.min(40, now - last); last = now;

  b2.x += b2.vx*dt; b2.y += b2.vy*dt;
  const w = bg2.clientWidth, h = bg2.clientHeight;
  const rect = canvas.getBoundingClientRect();  const boundW = rect.width, boundH = canvas.offsetHeight;
  if(b2.x < -w*0.2){ b2.x = -w*0.2; b2.vx = Math.abs(b2.vx); }
  if(b2.y < -h*0.2){ b2.y = -h*0.2; b2.vy = Math.abs(b2.vy); }
  if(b2.x + w*1.2 > boundW){ b2.x = boundW - w*1.2; b2.vx = -Math.abs(b2.vx); }
  if(b2.y + h*1.2 > boundH){ b2.y = boundH - h*1.2; b2.vy = -Math.abs(b2.vy); }
  bg2Wrap.style.transform = `translate3d(${b2.x}px, ${b2.y}px, 0)`;

  for(const chip of chips){
    chip.x += chip.vx*dt; chip.y += chip.vy*dt;
    chip.vx *= 0.990; chip.vy *= 0.990;
    chip.vx += (Math.random()-0.5)*0.0006; chip.vy += (Math.random()-0.5)*0.0006;
    applyChipTransform(chip);
  }
  resolveCollisions();
  requestAnimationFrame(tick);
}

/* UPDATE RANKING (DOM) */
function updateRanking(newList){
  ranking = newList.slice(0,9);
  chips.forEach((chip,i)=>{
    chip.name.textContent = ranking[i]?.name || '—';
    chip.time.textContent = ranking[i]?.time || '—';
  });
}

/* ===== 서버에서 Top9 불러오기 ===== */
const GET_URL = "https://script.google.com/macros/s/AKfycbyW80ocyuXeZKgauKt6oOgMvacUHbxQxDLBRHWIXKTJr1ySScNTv20-NWxSaWp-LzHD/exec";


function getJSONP(url){
  return new Promise((resolve, reject)=>{
    const cbName = `jsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    window[cbName] = (data)=>{ resolve(data); cleanup(); };

    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
    s.onerror = ()=>{ reject(new Error('JSONP failed')); cleanup(); };
    document.body.appendChild(s);

    function cleanup(){
      try { delete window[cbName]; } catch(_){}
      if (s.parentNode) s.parentNode.removeChild(s);
    }
  });
}


function fmt(sec){ const m=Math.floor(sec/60), s=sec%60; return `${m}:${String(s).padStart(2,'0')}`; }

async function fetchAndRefresh(){
  try{
    const d = await getJSONP(GET_URL); // { data: [...] }
    const rows = (d?.data || []).filter(r => Number.isFinite(+r.seconds))
                                .sort((a,b)=>a.seconds-b.seconds);
    const fmt = s => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
    const top9 = rows.slice(0,9).map(r => ({ name: r.name || '—', time: fmt(+r.seconds) }));
    updateRanking(top9);

    // (원래 넣어둔 느린 폴링/백오프 스케줄러 계속 사용해도 OK)
  }catch(e){
    console.warn('fetchAndRefresh failed:', e);
  }
}
/* === 느린 폴링 + 429 백오프 스케줄러 === */
let pollTimer = null;
let waitMs = 60000;                         // 기본 60초
const MIN = 60000, MAX = 300000;            // 60s ~ 5m

function schedule(ms){
  clearTimeout(pollTimer);
  pollTimer = setTimeout(fetchAndRefresh, ms);
}

async function fetchAndRefresh(){
  try{
    const res = await fetch(GET_URL, { cache: 'no-store' });

    // 429: 레이트 리밋 → 쉬었다가 다시
    if (res.status === 429){
      waitMs = Math.min(Math.max(waitMs * 2, 120000), MAX);  // 최소 2분, 최대 5분
      return schedule(waitMs);
    }

    const d = await res.json();

    // 응답 파싱 (객체 배열/2차원 배열 모두 처리)
    let rows = [];
    if (Array.isArray(d?.data)) {
      const first = d.data[0];
      if (first && typeof first === 'object' && !Array.isArray(first)) {
        // 현재 네 구조: {data:[{name,seconds,...}]}
        rows = d.data.map(o => ({ name:String(o?.name ?? ''), seconds:Number(o?.seconds) }));
      } else {
        // 2차원 배열형
        rows = d.data.map(r => ({ name:String(r[1] ?? ''), seconds:Number(r[2]) }));
      }
    } else if (Array.isArray(d)) {
      rows = d.map(o => ({ name:String(o?.name ?? ''), seconds:Number(o?.seconds) }));
    } else if (Array.isArray(d?.rows)) {
      rows = d.rows.map(r => ({ name:String(r[1] ?? ''), seconds:Number(r[2]) }));
    } else {
      console.error('Unexpected response shape:', d);
      waitMs = Math.min(waitMs * 2, MAX);
      return schedule(waitMs);
    }

    rows = rows.filter(r => Number.isFinite(r.seconds))
               .sort((a,b)=>a.seconds - b.seconds);

    const fmt = s => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
    const top9 = rows.slice(0,9).map(r => ({ name:r.name || '—', time:fmt(r.seconds) }));

    updateRanking(top9);                     // ← 기존 UI 갱신 함수 그대로 사용

    // 성공했으면 주기 원복
    waitMs = MIN;
    schedule(waitMs);

  }catch(e){
    console.warn('fetchAndRefresh failed:', e);
    waitMs = Math.min(waitMs * 2, MAX);      // 실패 시 점점 늘림
    schedule(waitMs);
  }
}

// 탭이 다시 보일 때 한 번만 즉시 갱신
document.addEventListener('visibilitychange', ()=>{
  if (!document.hidden) fetchAndRefresh();
});

// === 버전 감시(JSONP)로 '즉시 반영' ===
const VER_BASE_URL = GET_URL + (GET_URL.includes('?') ? '&' : '?') + 'action=ver';

let lastVer = '0';
let verTimer = null;

function getJSONP(url){
  return new Promise((resolve, reject)=>{
    const cbName = `jsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    window[cbName] = (data)=>{ resolve(data); cleanup(); };

    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
    s.async = true;
    s.onerror = ()=>{ reject(new Error('JSONP failed')); cleanup(); };
    document.body.appendChild(s);

    function cleanup(){
      try{ delete window[cbName]; }catch(_){}
      if (s.parentNode) s.parentNode.removeChild(s);
    }
  });
}

async function watchVersionOnce(){
  try{
    const d = await getJSONP(VER_BASE_URL);
    const v = String(d?.ver ?? '0');
    if (v && v !== lastVer){
      lastVer = v;
      // 버전이 바뀌면 즉시 Top9 다시 로드
      await fetchAndRefreshOnce();
    }
  }catch(e){
    // 조용히 무시 (네트워크 이슈 등)
  }
}

function startVersionWatch(){
  clearInterval(verTimer);
  // 2초 주기로 아주 가볍게 확인 (JSONP로 헤더/프리플라이트가 없어 부담 적음)
  verTimer = setInterval(watchVersionOnce, 2000);
}


/* ===== 서버 연동 끝 ===== */

/* INIT */
createChips();
requestAnimationFrame(tick);
fetchAndRefresh();   // ← 요거 한 줄만
startVersionWatch();


window.addEventListener('resize', ()=>{ chips.forEach(applyChipTransform); });
document.addEventListener('visibilitychange', ()=>{ if(!document.hidden){ last = performance.now(); requestAnimationFrame(tick); }});

/* COLLISIONS */
function resolveCollisions(){
  const bounce = 0.4;
  for(let i=0;i<chips.length;i++){
    for(let j=i+1;j<chips.length;j++){
      const a=chips[i], b=chips[j];
      const aw=a.el.offsetWidth, ah=a.el.offsetHeight;
      const bw=b.el.offsetWidth, bh=b.el.offsetHeight;
      const overlapX=(a.x < b.x + bw) && (a.x + aw > b.x);
      const overlapY=(a.y < b.y + bh) && (a.y + ah > b.y);
      if(!(overlapX && overlapY)) continue;

      const axc=a.x+aw/2, ayc=a.y+ah/2, bxc=b.x+bw/2, byc=b.y+bh/2;
      const dx=axc-bxc, dy=ayc-byc;
      const px=aw/2+bw/2 - Math.abs(dx), py=ah/2+bh/2 - Math.abs(dy);
      const moveA=!a.dragging, moveB=!b.dragging;

      if(px < py){
        const sx = dx < 0 ? -px : px;
        if(moveA && moveB){ a.x += sx/2; b.x -= sx/2; } else if(moveA){ a.x += sx; } else if(moveB){ b.x -= sx; }
        const avx=a.vx, bvx=b.vx; if(moveA) a.vx=bvx*bounce; if(moveB) b.vx=avx*bounce;
      }else{
        const sy = dy < 0 ? -py : py;
        if(moveA && moveB){ a.y += sy/2; b.y -= sy/2; } else if(moveA){ a.y += sy; } else if(moveB){ b.y -= sy; }
        const avy=a.vy, bvy=b.vy; if(moveA) a.vy=bvy*bounce; if(moveB) b.vy=avy*bounce;
      }
      applyChipTransform(a); applyChipTransform(b);
    }
  }
}
</script>
</body>
</html>
