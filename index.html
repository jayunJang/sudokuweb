<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Sudoku Festival – Archive (Top 9)</title>
  <style>
@import url('https://fonts.googleapis.com/css2?family=Lexend+Deca:wght@100..900&family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

:root{
  --red:#E7364E; --white:#fff; --blue:#9ED4FF;
  --gap: 8px;
  --stroke: 2px;
  --shadow: 0 4px 12px rgba(0,0,0,.18);
}

html,body{ width:100%; background:#fff; filter: noise(1px);}
body{
  margin:0;
  overflow:auto;
  font-family:"Lexend Deca", system-ui;
  color:rgba(231,54,78,1.0);
}

/* 스크롤 가능한 캔버스 */
#canvas{ position:relative; width:100%; height:190vh; }

/* LAYERS */
.layer{ position:absolute; inset:0; pointer-events:none; }
#bg1{ z-index:1; background:url('bg1.png') center/cover no-repeat; }
#bg2-wrap{ z-index:3; display:flex; align-items:center; justify-content:center; margin:120px; padding-top:230px;}
#bg2{ width:900px; max-width:none; display:block; }
#bg3{ z-index:4; background:url('bg3.png') right/contain no-repeat; margin:70px; }

/* TAGLINE */
.tagline{
  position:fixed; left:50%; top:24px; transform:translateX(-50%);
  z-index:8; color:var(--white);
  font-weight:800; letter-spacing:.2px; padding:8px 14px;
  background:var(--red); border-radius:10px; box-shadow:var(--shadow); pointer-events:none
}

/* STAGE */
#stage{ position:absolute; inset:0; z-index:6; pointer-events:none; }

/* CHIP */
.chip{
  position:fixed;
  display:flex; align-items:center; gap:var(--gap);
  cursor:grab; touch-action:none; pointer-events:auto; padding-left:50px;
}
.chip.dragging{ cursor:grabbing; }
.chip img.num{ width: calc(var(--scale, 1) * clamp(64px, 12vw, 85px)); height:auto; display:block; }

/* META */
.meta{
  display:flex; flex-direction:column; gap:2px; font-weight:600; line-height:1.1; text-align:left;
  color:rgba(231,54,78,1.0);
  text-shadow:
    1px  1px 0 #fff, -1px  1px 0 #fff,
    1px -1px 0 #fff, -1px -1px 0 #fff,
    0    2px 0 #fff,  0   -2px 0 #fff,
    2px  0   0 #fff, -2px  0   0 #fff;
}
.meta .name{ font-size:clamp(18px,2.4vw,22px); }
.meta .time{ font-size:clamp(16px,2.0vw,18px); opacity:.95; }

.hud{
  position:fixed; left:70%; top:50%; transform:translate(-50%,-50%);
  z-index:6; width:min(100vw, 1000px); aspect-ratio:16/9;color: #E7364E;
  display:flex; flex-direction:row; place-items:left ; pointer-events:none;
}
/* 중앙 실시간 영역 */
#live-wrap{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  z-index:6; width:min(100vw, 1000px); aspect-ratio:16/9;
  display:grid; place-items:center; pointer-events:none; margin: 20px;
}
canvas#live{ width:90%; height:90%; pointer-events:none; background-color:none;}
video#cam{ display:none; }


  </style>
</head>
<body>
  <div id="canvas">
    <div id="bg1" class="layer"></div>
    <div id="bg2-wrap" class="layer"><img id="bg2" src="bg2.png" alt="bg2"/></div>
    <div id="bg3" class="layer"></div>
    <div id="stage"></div>
  </div>

  <!-- 중앙 라이브 카메라 + 모자이크 렌더 캔버스 -->
  <div id="live-wrap">
    <canvas id="live"></canvas>
    <video id="cam" playsinline></video>
  </div>

  <div class="hud" aria-live="polite">
    <span class="dot"></span>
    <span>motion</span>&nbsp;&nbsp;<span class="v" id="motionV">0.00</span>
    <span style="margin-left:20px;">complete immersion
    </span>&nbsp;&nbsp;<span class="v" id="focusV">0</span>
    <span style="margin-left:20px;">distraction</span>&nbsp;&nbsp;<span class="v" id="distV">0</span>
  </div>

  <button id="bgToggle" style="position:fixed; top:65px; left:70px; z-index:10; background:var(--red); border:none; border-radius:100px;font-family: Lexend Deca, system-ui; color: white;"></button>

<script>
/** CONFIG */
const NUM_ASSETS = [
  {rank:1, src:'n1.png'},{rank:2, src:'n2.png'},{rank:3, src:'n3.png'},
  {rank:4, src:'n4.png'},{rank:5, src:'n5.png'},{rank:6, src:'n6.png'},
  {rank:7, src:'n7.png'},{rank:8, src:'n8.png'},{rank:9, src:'n9.png'},
];
let ranking = Array.from({length:9}, ()=>({name:'—', time:'—'}));

/* ELEMENTS */
const canvas = document.getElementById('canvas');
const stage  = document.getElementById('stage');
const bg2Wrap = document.getElementById('bg2-wrap');
const bg2 = document.getElementById('bg2');
const chips = [];

/* BG2 */
let b2 = {x:0, y:0, vx:0.02, vy:0.015};
function layoutBg2(){
  const rect = canvas.getBoundingClientRect();
  b2.x = rect.width * 0.5 - bg2.clientWidth * 0.5;
  b2.y = rect.height * 0.5 - bg2.clientHeight * 0.5;
}
window.addEventListener('load', layoutBg2);
window.addEventListener('resize', layoutBg2);

/* CHIPS */
function createChips(){
  stage.innerHTML = ''; chips.length = 0;
  NUM_ASSETS.forEach((item, i) => {
    const chipEl = document.createElement('div');
    chipEl.className = 'chip';
    const col = i % 3, row = Math.floor(i / 3);
    const startX = (5 + col*30) * window.innerWidth / 100;
    const startY = (15 + row*30) * window.innerHeight / 100 + window.scrollY;

    const img = new Image();
    img.className = 'num'; img.src = item.src; img.alt = 'rank ' + item.rank;
    if (item.rank === 4) img.style.setProperty('--scale', '1.2');

    const meta = document.createElement('div'); meta.className = 'meta';
    const name = document.createElement('div'); name.className = 'name'; name.textContent = ranking[i]?.name || '—';
    const time = document.createElement('div'); time.className = 'time'; time.textContent = ranking[i]?.time || '—';
    meta.append(name, time);
    chipEl.append(img, meta);
    stage.appendChild(chipEl);

    const chip = { el: chipEl, img, meta, name, time,
      x:startX, y:startY,
      vx:(Math.random()*0.05+0.015)*(Math.random()<.5?-1:1),
      vy:(Math.random()*0.05+0.015)*(Math.random()<.5?-1:1)
    };
    chips.push(chip);
    applyChipTransform(chip);
    enableDrag(chip);
  });
}

/* DRAG */
function enableDrag(chip){
  let dragging=false, lastT=0, grabDX=0, grabDY=0, prevX=0, prevY=0;
  const el = chip.el;

  const onPointerDown = (e)=>{
    dragging=true; chip.dragging=true; el.classList.add('dragging'); el.setPointerCapture(e.pointerId);
    const rect = el.getBoundingClientRect();
    grabDX = e.clientX - rect.left; grabDY = e.clientY - rect.top;
    prevX = chip.x; prevY = chip.y; lastT = performance.now(); chip.vx = chip.vy = 0;
  };
  const onPointerMove = (e)=>{
    if(!dragging) return;
    chip.x = e.clientX - grabDX; chip.y = e.clientY - grabDY;
    applyChipTransform(chip);
    const now = performance.now(), dt = Math.max(1, now - lastT);
    chip.vx = (chip.x - prevX) / dt; chip.vy = (chip.y - prevY) / dt;
    prevX = chip.x; prevY = chip.y; lastT = now;
  };
  const onPointerUp = ()=>{ dragging=false; chip.dragging=false; el.classList.remove('dragging'); };
  el.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

/* BOUNDS */
function applyChipTransform(chip){
  const w = chip.el.offsetWidth, h = chip.el.offsetHeight;
  const stageW = window.innerWidth, stageH = window.innerHeight;
  if (chip.x < 0) chip.x = 0;
  if (chip.y < 0) chip.y = 0;
  if (chip.x + w > stageW) chip.x = stageW - w;
  if (chip.y + h > stageH) chip.y = stageH - h;
  chip.el.style.transform = `translate3d(${chip.x}px, ${chip.y}px, 0)`;
}

/* TICK */
let last = performance.now();
function tick(now){
  const dt = Math.min(40, now - last); last = now;

  b2.x += b2.vx*dt; b2.y += b2.vy*dt;
  const w = bg2.clientWidth, h = bg2.clientHeight;
  const rect = canvas.getBoundingClientRect();  const boundW = rect.width, boundH = canvas.offsetHeight;
  if(b2.x < -w*0.2){ b2.x = -w*0.2; b2.vx = Math.abs(b2.vx); }
  if(b2.y < -h*0.2){ b2.y = -h*0.2; b2.vy = Math.abs(b2.vy); }
  if(b2.x + w*1.2 > boundW){ b2.x = boundW - w*1.2; b2.vx = -Math.abs(b2.vx); }
  if(b2.y + h*1.2 > boundH){ b2.y = boundH - h*1.2; b2.vy = -Math.abs(b2.vy); }
  bg2Wrap.style.transform = `translate3d(${b2.x}px, ${b2.y}px, 0)`;

  for(const chip of chips){
    chip.x += chip.vx*dt; chip.y += chip.vy*dt;
    chip.vx *= 0.990; chip.vy *= 0.990;
    chip.vx += (Math.random()-0.5)*0.0006; chip.vy += (Math.random()-0.5)*0.0006;
    applyChipTransform(chip);
  }
  resolveCollisions();
  requestAnimationFrame(tick);
}

/* UPDATE RANKING (DOM) - 기존 UI는 사용하지 않음 (호출 제거) */
function updateRanking(newList){
  ranking = newList.slice(0,9);
  chips.forEach((chip,i)=>{
    chip.name.textContent = ranking[i]?.name || '—';
    chip.time.textContent = ranking[i]?.time || '—';
  });
}

/* ===== 서버에서 Top9 불러오기 ===== */
const GET_URL = "https://script.google.com/macros/s/AKfycbyW80ocyuXeZKgauKt6oOgMvacUHbxQxDLBRHWIXKTJr1ySScNTv20-NWxSaWp-LzHD/exec";


function getJSONP(url){
  return new Promise((resolve, reject)=>{
    const cbName = `jsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    window[cbName] = (data)=>{ resolve(data); cleanup(); };

    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
    s.onerror = ()=>{ reject(new Error('JSONP failed')); cleanup(); };
    document.body.appendChild(s);

    function cleanup(){
      try { delete window[cbName]; } catch(_){}
      if (s.parentNode) s.parentNode.removeChild(s);
    }
  });
}


function fmt(sec){ const m=Math.floor(sec/60), s=sec%60; return `${m}:${String(s).padStart(2,'0')}`; }

async function fetchAndRefresh(){
  try{
    const d = await getJSONP(GET_URL); // { data: [...] }
    const rows = (d?.data || []).filter(r => Number.isFinite(+r.seconds))
                                .sort((a,b)=>a.seconds-b.seconds);
    const fmt = s => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
    const top9 = rows.slice(0,9).map(r => ({ name: r.name || '—', time: fmt(+r.seconds) }));
    updateRanking(top9);

    // (원래 넣어둔 느린 폴링/백오프 스케줄러 계속 사용해도 OK)
  }catch(e){
    console.warn('fetchAndRefresh failed:', e);
  }
}
/* === 느린 폴링 + 429 백오프 스케줄러 === */
let pollTimer = null;
let waitMs = 60000;                         // 기본 60초
const MIN = 60000, MAX = 300000;            // 60s ~ 5m

function schedule(ms){
  clearTimeout(pollTimer);
  pollTimer = setTimeout(fetchAndRefresh, ms);
}

async function fetchAndRefresh(){
  try{
    const res = await fetch(GET_URL, { cache: 'no-store' });

    // 429: 레이트 리밋 → 쉬었다가 다시
    if (res.status === 429){
      waitMs = Math.min(Math.max(waitMs * 2, 120000), MAX);  // 최소 2분, 최대 5분
      return schedule(waitMs);
    }

    const d = await res.json();

    // 응답 파싱 (객체 배열/2차원 배열 모두 처리)
    let rows = [];
    if (Array.isArray(d?.data)) {
      const first = d.data[0];
      if (first && typeof first === 'object' && !Array.isArray(first)) {
        // 현재 네 구조: {data:[{name,seconds,...}]}
        rows = d.data.map(o => ({ name:String(o?.name ?? ''), seconds:Number(o?.seconds) }));
      } else {
        // 2차원 배열형
        rows = d.data.map(r => ({ name:String(r[1] ?? ''), seconds:Number(r[2]) }));
      }
    } else if (Array.isArray(d)) {
      rows = d.map(o => ({ name:String(o?.name ?? ''), seconds:Number(o?.seconds) }));
    } else if (Array.isArray(d?.rows)) {
      rows = d.rows.map(r => ({ name:String(r[1] ?? ''), seconds:Number(r[2]) }));
    } else {
      console.error('Unexpected response shape:', d);
      waitMs = Math.min(waitMs * 2, MAX);
      return schedule(waitMs);
    }

    rows = rows.filter(r => Number.isFinite(r.seconds))
               .sort((a,b)=>a.seconds - b.seconds);

    const fmt = s => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
    const top9 = rows.slice(0,9).map(r => ({ name:r.name || '—', time:fmt(r.seconds) }));

    updateRanking(top9);                     // ← 기존 UI 갱신 함수 그대로 사용

    // 성공했으면 주기 원복
    waitMs = MIN;
    schedule(waitMs);

  }catch(e){
    console.warn('fetchAndRefresh failed:', e);
    waitMs = Math.min(waitMs * 2, MAX);      // 실패 시 점점 늘림
    schedule(waitMs);
  }
}

// 탭이 다시 보일 때 한 번만 즉시 갱신
document.addEventListener('visibilitychange', ()=>{
  if (!document.hidden) fetchAndRefresh();
});

// === 버전 감시(JSONP)로 '즉시 반영' ===
const VER_BASE_URL = GET_URL + (GET_URL.includes('?') ? '&' : '?') + 'action=ver';

let lastVer = '0';
let verTimer = null;

function getJSONP(url){
  return new Promise((resolve, reject)=>{
    const cbName = `jsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    window[cbName] = (data)=>{ resolve(data); cleanup(); };

    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
    s.async = true;
    s.onerror = ()=>{ reject(new Error('JSONP failed')); cleanup(); };
    document.body.appendChild(s);

    function cleanup(){
      try{ delete window[cbName]; }catch(_){}
      if (s.parentNode) s.parentNode.removeChild(s);
    }
  });
}

async function watchVersionOnce(){
  try{
    const d = await getJSONP(VER_BASE_URL);
    const v = String(d?.ver ?? '0');
    if (v && v !== lastVer){
      lastVer = v;
      // 버전이 바뀌면 즉시 Top9 다시 로드
      await fetchAndRefreshOnce();
    }
  }catch(e){
    // 조용히 무시 (네트워크 이슈 등)
  }
}

function startVersionWatch(){
  clearInterval(verTimer);
  // 2초 주기로 아주 가볍게 확인 (JSONP로 헤더/프리플라이트가 없어 부담 적음)
  verTimer = setInterval(watchVersionOnce, 2000);
}


/* ===== 서버 연동 끝 ===== */

/* INIT (배경만 유지) */
requestAnimationFrame(tick);


window.addEventListener('resize', ()=>{ chips.forEach(applyChipTransform); });
document.addEventListener('visibilitychange', ()=>{ if(!document.hidden){ last = performance.now(); requestAnimationFrame(tick); }});

/* COLLISIONS */
function resolveCollisions(){
  const bounce = 0.4;
  for(let i=0;i<chips.length;i++){
    for(let j=i+1;j<chips.length;j++){
      const a=chips[i], b=chips[j];
      const aw=a.el.offsetWidth, ah=a.el.offsetHeight;
      const bw=b.el.offsetWidth, bh=b.el.offsetHeight;
      const overlapX=(a.x < b.x + bw) && (a.x + aw > b.x);
      const overlapY=(a.y < b.y + bh) && (a.y + ah > b.y);
      if(!(overlapX && overlapY)) continue;

      const axc=a.x+aw/2, ayc=a.y+ah/2, bxc=b.x+bw/2, byc=b.y+bh/2;
      const dx=axc-bxc, dy=ayc-byc;
      const px=aw/2+bw/2 - Math.abs(dx), py=ah/2+bh/2 - Math.abs(dy);
      const moveA=!a.dragging, moveB=!b.dragging;

      if(px < py){
        const sx = dx < 0 ? -px : px;
        if(moveA && moveB){ a.x += sx/2; b.x -= sx/2; } else if(moveA){ a.x += sx; } else if(moveB){ b.x -= sx; }
        const avx=a.vx, bvx=b.vx; if(moveA) a.vx=bvx*bounce; if(moveB) b.vx=avx*bounce;
      }else{
        const sy = dy < 0 ? -py : py;
        if(moveA && moveB){ a.y += sy/2; b.y -= sy/2; } else if(moveA){ a.y += sy; } else if(moveB){ b.y -= sy; }
        const avy=a.vy, bvy=b.vy; if(moveA) a.vy=bvy*bounce; if(moveB) b.vy=avy*bounce;
      }
      applyChipTransform(a); applyChipTransform(b);
    }
  }
}

/* ===== 중앙 라이브: Face Mesh + 숫자 모자이크 ===== */
(()=>{
  const video = document.getElementById('cam');
  const liveCanvas = document.getElementById('live');
  const ctx = liveCanvas.getContext('2d');
  const motionV = document.getElementById('motionV');
  const focusV  = document.getElementById('focusV');
  const distV   = document.getElementById('distV');

  const COLORS = ['#e1394e', '#afdeff', '#fff4ac'];
  const DIGITS = ['1','2','3','4','5','6','7','8','9'];

  let baseGridCols = 40, baseGridRows = 22;
  let gridCols = 40, gridRows = 22;
  let cells = [];
  let prevLandmarks = null;
  let motionScore = 0;  // 0..1
  let focusScore = 0;   // 0..100
  let distractionScore = 0; // 0..100

  function resizeLive(){
    const r = liveCanvas.getBoundingClientRect();
    liveCanvas.width = Math.floor(r.width * devicePixelRatio);
    liveCanvas.height = Math.floor(r.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

    // 기본 그리드 크기 설정
    baseGridCols = Math.max(24, Math.floor(r.width / 20));
    baseGridRows = Math.max(14, Math.floor(r.height / 20));
    updateGridSize();
  }
  window.addEventListener('resize', resizeLive);

  // 움직임에 따라 그리드 크기 업데이트 (움직임이 크면 블록이 큼 = 셀 수가 적음)
  function updateGridSize(){
    // motionScore가 0이면 최대 셀 수 (작은 블록), 1이면 최소 셀 수 (큰 블록)
    // 움직임이 많을수록 블록이 커지도록 더 극단적으로 조절
    // 최소 셀 크기를 더 작게 (움직임이 가장 작을 때 셀이 더 많아지도록)
    // 숫자 간 간격을 줄이기 위해 최대 셀 수를 늘림
    const minCols = Math.max(8, Math.floor(baseGridCols * 0.15)); // 최소 셀 수 (큰 블록) - 더 작게
    const maxCols = Math.floor(baseGridCols * 2.2); // 최대 셀 수 증가 (작은 블록, 간격 줄이기)
    gridCols = Math.floor(map(motionScore, 0, 1, maxCols, minCols));
    
    const minRows = Math.max(6, Math.floor(baseGridRows * 0.15)); // 최소 셀 수 (큰 블록) - 더 작게
    const maxRows = Math.floor(baseGridRows * 2.2); // 최대 셀 수 증가 (작은 블록, 간격 줄이기)
    gridRows = Math.floor(map(motionScore, 0, 1, maxRows, minRows));
    
    // 셀 배열 재생성
    cells = [];
    for(let y=0;y<gridRows;y++){
      for(let x=0;x<gridCols;x++){
        // 격자 효과를 줄이기 위해 각 셀별로 고정된 랜덤 오프셋 저장
        const seed = (x * 37 + y * 71) % 1000; // 셀별 고유 시드
        const offsetX = (seed / 1000 - 0.5) * 0.15; // -0.075 ~ 0.075
        const offsetY = ((seed * 7) % 1000 / 1000 - 0.5) * 0.15; // -0.075 ~ 0.075
        cells.push({
          x, y,
          digit: DIGITS[Math.floor(Math.random()*9)],
          color: COLORS[Math.floor(Math.random()*COLORS.length)],
          offsetX, offsetY, // 고정된 랜덤 오프셋
        });
      }
    }
  }

  function map(n, a, b, c, d){ return c + (n - a) * (d - c) / (b - a); }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  // 웹캠 영상을 픽셀리제이션하기 위한 임시 캔버스
  let tempCanvas = null;
  let tempCtx = null;
  // 백그라운드용 캔버스 (웹캠 영상 + 흑백 + 블러)
  let bgCanvas = null;
  let bgCtx = null;
  let showBackground = true; // 백그라운드 표시 여부

  // 백그라운드 토글 버튼 (DOM 로드 후 초기화)
  document.addEventListener('DOMContentLoaded', ()=>{
    const bgToggleBtn = document.getElementById('bgToggle');
    if(bgToggleBtn){
      bgToggleBtn.addEventListener('click', ()=>{
        showBackground = !showBackground;
        bgToggleBtn.textContent = showBackground ? 'Hide Background' : 'Show Background';
      });
    }
  });

  function renderMosaic(){
    if(!video || video.readyState < 2) return;
    
    const w = liveCanvas.width / devicePixelRatio;
    const h = liveCanvas.height / devicePixelRatio;
    ctx.clearRect(0,0,w,h);

    // 백그라운드 표시 여부에 따라 그리기
    if(showBackground){
      // 백그라운드 캔버스 초기화
      if(!bgCanvas || bgCanvas.width !== w || bgCanvas.height !== h){
        bgCanvas = document.createElement('canvas');
        bgCanvas.width = w;
        bgCanvas.height = h;
        bgCtx = bgCanvas.getContext('2d');
      }

      // 백그라운드: 웹캠 영상 그대로 + 흑백 + 가우시안 블러
      bgCtx.clearRect(0, 0, w, h);
      
      // 웹캠 영상 그리기
      bgCtx.drawImage(video, 0, 0, w, h);
      
      // 흑백 필터 적용
      const bgImageData = bgCtx.getImageData(0, 0, w, h);
      const bgData = bgImageData.data;
      for(let i = 0; i < bgData.length; i += 4){
        const gray = bgData[i] * 0.299 + bgData[i + 1] * 0.587 + bgData[i + 2] * 0.114;
        bgData[i] = gray;     // R
        bgData[i + 1] = gray; // G
        bgData[i + 2] = gray; // B
      }
      bgCtx.putImageData(bgImageData, 0, 0);
      
      // 가우시안 블러 적용 (0.5% = 캔버스 크기의 0.5%)
      const blurRadius = Math.max(1, Math.floor(Math.min(w, h) * 0.005));
      ctx.filter = `blur(${blurRadius}px)`;
      ctx.drawImage(bgCanvas, 0, 0);
      ctx.filter = 'none';
    }

    // 임시 캔버스 초기화
    if(!tempCanvas || tempCanvas.width !== w || tempCanvas.height !== h){
      tempCanvas = document.createElement('canvas');
      tempCanvas.width = w;
      tempCanvas.height = h;
      tempCtx = tempCanvas.getContext('2d');
    }

    // 웹캠 영상을 임시 캔버스에 그리기 (픽셀리제이션을 위해 작은 크기로)
    const pixelSize = Math.max(8, Math.floor(map(motionScore, 0, 1, 12, 6)));
    const scaledW = Math.floor(w / pixelSize);
    const scaledH = Math.floor(h / pixelSize);
    
    tempCtx.drawImage(video, 0, 0, scaledW, scaledH);
    
    // 픽셀 데이터 읽기 (픽셀리제이션된 영상은 표시하지 않음, 숫자만 표시)
    const imageData = tempCtx.getImageData(0, 0, scaledW, scaledH);
    const data = imageData.data;

    // 그리드 셀 크기 (블록 크기)
    const cw = w / gridCols;
    const ch = h / gridRows;
    // 숫자 크기는 블록 크기에 비례 (블록이 크면 숫자도 크게, 셀을 꽉 차게)
    // 숫자 간 간격을 줄이기 위해 크기를 키워서 오버랩 허용
    const digitSize = Math.min(cw, ch) * 1.1;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 각 셀에 대해 픽셀 평균 색상 계산 및 숫자 매핑
    // 격자 효과를 줄이기 위해 샘플링 영역을 오버랩시키고 위치를 약간 랜덤하게
    for(const c of cells){
      // 샘플링 영역을 오버랩시켜서 경계를 흐리게 (10% 오버랩)
      const overlap = 0.1;
      const cellWidth = scaledW / gridCols;
      const cellHeight = scaledH / gridRows;
      const startX = Math.max(0, Math.floor((c.x / gridCols) * scaledW - cellWidth * overlap));
      const startY = Math.max(0, Math.floor((c.y / gridRows) * scaledH - cellHeight * overlap));
      const endX = Math.min(scaledW, Math.floor(((c.x + 1) / gridCols) * scaledW + cellWidth * overlap));
      const endY = Math.min(scaledH, Math.floor(((c.y + 1) / gridRows) * scaledH + cellHeight * overlap));
      
      let r = 0, g = 0, b = 0, count = 0;
      
      for(let py = startY; py < endY; py++){
        for(let px = startX; px < endX; px++){
          const idx = (py * scaledW + px) * 4;
          r += data[idx];
          g += data[idx + 1];
          b += data[idx + 2];
          count++;
        }
      }
      
      let brightness = 128;
      let fontWeight = 400;
      if(count > 0){
        r = Math.floor(r / count);
        g = Math.floor(g / count);
        b = Math.floor(b / count);
        brightness = (r + g + b) / 3;
        
        // 숫자를 랜덤하게 배치 (밝기와 무관)
        c.digit = DIGITS[Math.floor(Math.random() * 9)];
        
        // 밝기에 따라 폰트 웨이트 조절 (밝으면 라이트, 어두우면 볼드) - 더 극단적으로
        // 밝기가 0이면 900, 255이면 100으로 극단적으로 조절
        fontWeight = Math.floor(map(brightness, 0, 255, 900, 100));
        fontWeight = clamp(fontWeight, 100, 900);
        
        // 폰트 웨이트를 더 극단적으로 조절 (100, 300, 400, 700, 900만 사용)
        if(fontWeight < 200){
          fontWeight = 90; // 매우 밝음
        } else if(fontWeight < 350){
          fontWeight = 300; // 밝음
        } else if(fontWeight < 550){
          fontWeight = 400; // 중간
        } else if(fontWeight < 800){
          fontWeight = 700; // 어두움
        } else {
          fontWeight = 900; // 매우 어두움
        }
        
        // 빨간색(#E7364E)만 사용해서 범위 내에서 밝기 조절
        // #E7364E: RGB(231, 54, 78) - 기본 빨간색
        // 빨간색의 비율(R:G:B)을 유지하면서 밝기만 조절
        const brightnessRatio = clamp(brightness / 255, 0, 1);
        
        const baseR = 231, baseG = 54, baseB = 78;  // #E7364E
        
        // 빨간색(#E7364E)과 파란색(#ADDBF6)을 사용하여 밝기 조절
        // 기존 빨간색(#E7364E)이 가장 어두운 색상 (더 어두워지지 않음)
        // 밝기를 4단계로 나눔 (대비감 증가)
        // 파란색: #ADDBF6 = RGB(173, 219, 246)
        const blueR = 173, blueG = 219, blueB = 246; // #ADDBF6
        
        let finalR, finalG, finalB;
        if(brightnessRatio < 0.45){
          // 가장 어두움: 기존 빨간색 (흰색 안 섞음)
          finalR = baseR;
          finalG = baseG;
          finalB = baseB;
        } else if(brightnessRatio < 0.5){
          // 어두움: 빨간색에 흰색 10% 섞기
          const whiteMixRatio = 0.1;
          finalR = Math.floor(baseR * (1 - whiteMixRatio) + 255 * whiteMixRatio);
          finalG = Math.floor(baseG * (1 - whiteMixRatio) + 255 * whiteMixRatio);
          finalB = Math.floor(baseB * (1 - whiteMixRatio) + 255 * whiteMixRatio);
        } else if(brightnessRatio < 0.75){
          // 밝음: 파란색 (#ADDBF6)
          finalR = blueR;
          finalG = blueG;
          finalB = blueB;
        } else {
          // 가장 밝음: 파란색에 흰색 30% 섞기
          const whiteMixRatio = 0.3;
          finalR = Math.floor(blueR * (1 - whiteMixRatio) + 255 * whiteMixRatio);
          finalG = Math.floor(blueG * (1 - whiteMixRatio) + 255 * whiteMixRatio);
          finalB = Math.floor(blueB * (1 - whiteMixRatio) + 255 * whiteMixRatio);
        }
        
        c.color = `rgb(${finalR},${finalG},${finalB})`;
      } else {
        // 기존 빨간색이 최소 어둡기 (더 어두워지지 않음)
        c.color = '#E7364E'; // RGB(231, 54, 78)
        c.digit = DIGITS[Math.floor(Math.random() * 9)];
        fontWeight = 900; // 어두운 곳은 볼드
      }
      
      // 숫자 위치를 약간 랜덤하게 이동하여 격자 효과 줄이기
      // 셀별로 고정된 오프셋 사용 (매 프레임마다 바뀌지 않음)
      const cx = (c.x + 0.5 + (c.offsetX || 0)) * cw;
      const cy = (c.y + 0.5 + (c.offsetY || 0)) * ch;
      
      // 폰트 설정 (밝기에 따라 웨이트 조절)
      ctx.font = `${fontWeight} ${digitSize}px "Lexend Deca", system-ui`;
      
      // 숫자만 그리기 (픽셀 블록 제거)
      ctx.fillStyle = c.color;
      ctx.fillText(c.digit, cx, cy);
    }
  }

  function mosaicLoop(){
    renderMosaic();
    requestAnimationFrame(mosaicLoop);
  }

  function updateMetrics(landmarks){
    if(!Array.isArray(landmarks) || landmarks.length === 0){
      const prevMotionScore = motionScore;
      motionScore = motionScore * 0.9;
      if(Math.abs(motionScore - prevMotionScore) > 0.01){
        updateGridSize();
      }
      focusScore = Math.max(0, focusScore - 1);
      distractionScore = Math.max(0, distractionScore - 1);
      return;
    }

    let avgMove = 0;
    if(prevLandmarks){
      const n = Math.min(prevLandmarks.length, landmarks.length);
      let sum = 0;
      for(let i=0;i<n;i++){
        const a = prevLandmarks[i];
        const b = landmarks[i];
        const dx = a.x - b.x, dy = a.y - b.y;
        sum += Math.hypot(dx, dy);
      }
      avgMove = sum / n;
    }
    prevLandmarks = landmarks.map(p=>({x:p.x, y:p.y, z:p.z}));

    const leftEye = landmarks[33];
    const rightEye = landmarks[263];
    const nose = landmarks[1];
    const eyeDx = Math.abs(leftEye.x - rightEye.x);
    const noseToEyes = Math.abs(nose.y - (leftEye.y + rightEye.y)/2);
    const headPose = clamp((noseToEyes / (eyeDx + 1e-5)) - 0.8, 0, 1);

    const upperLip = landmarks[13];
    const lowerLip = landmarks[14];
    const mouthOpen = clamp(Math.abs(upperLip.y - lowerLip.y) / (eyeDx + 1e-5), 0, 1);

    const moveNorm = clamp(map(avgMove, 0.001, 0.01, 0, 1), 0, 1);
    const prevMotionScore = motionScore;
    motionScore = motionScore*0.85 + moveNorm*0.15;

    // motionScore가 변경되면 그리드 크기 업데이트 (매번 체크)
    if(Math.abs(motionScore - prevMotionScore) > 0.001){
      updateGridSize();
    }

    let focus = (1 - moveNorm) * (1 - mouthOpen*0.7) * (1 - headPose*0.6);
    focus = clamp(focus, 0, 1);
    focusScore = Math.round(focus * 100);

    let distraction = moveNorm*0.6 + mouthOpen*0.3 + headPose*0.4;
    distraction = clamp(distraction, 0, 1);
    distractionScore = Math.round(distraction * 100);

    motionV.textContent = motionScore.toFixed(2);
    focusV.textContent = String(focusScore);
    distV.textContent = String(distractionScore);
  }

  async function initMedia(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream; await video.play();
      resizeLive();

      const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
      faceMesh.setOptions({ maxNumFaces: 2, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
      faceMesh.onResults((res)=>{
        const faces = res.multiFaceLandmarks || [];
        if(faces[0]) updateMetrics(faces[0]); else updateMetrics(null);
      });

      const camera = new Camera(video, { onFrame: async ()=>{ await faceMesh.send({image: video}); }, width:1280, height:720 });
      camera.start();

      requestAnimationFrame(mosaicLoop);
    }catch(e){
      console.warn('Camera init failed:', e);
    }
  }
  
  // 외부 CDN 로딩 보장 후 시작
  function waitForGlobals(){
    if (window.FaceMesh && window.Camera){ initMedia(); }
    else { setTimeout(waitForGlobals, 50); }
  }
  waitForGlobals();
})();
</script>
<!-- MediaPipe CDN -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</body>
</html>
